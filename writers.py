#!/usr/bin/python
from cppentities import *


class CAPIWriter(object):
    """Object that can write the pure C API corresponding to a given CPPClass object."""
    def __init__(self, filename):
        """filename is the name of the files, without extension, to which the CAPIWriter will write text."""
        self._headerFilename = filename + '.h'
        self._implementationFilename = filename + '.cpp'
        self.initializeDeclaration()
        self.initializeImplementation()

    def initializeDeclaration(self):
        """Adds its header to the C API header file."""
        with open(self._headerFilename, 'w') as f:
            f.write('/* File automatically generated by the pybindings project.\n'
                    'This file declare a pure C API for the C++ objects.\n'
                    'The following macros represent the standard way of making\n'
                    'exporting symbols from a DLL simpler. Linux part still to do. */\n'
                    '#ifdef PYBINDING_EXPORTS\n'
                    '#define PYBINDING_API __declspec(dllexport)\n'
                    '#else\n'
                    '#define PYBINDING_API __declspec(dllimport)\n'
                    '#endif\n\n'
                    '#include // Get file name from class!\n\n'
                    'extern "C"\n'
                    '{\n')

    def finalizeDeclaration(self):
        """Finalizes the file by closing braces etc."""
        with open(self._headerFilename, 'a') as f:
            f.write('}\n\n')

    def initializeImplementation(self):
        """Adds its header to the C API implementation file."""
        with open(self._implementationFilename, 'w') as f:
            f.write('/* File automatically generated by the pybindings project.\n' +
                    'This file implements a pure C API for the C++ objects. */\n' +
                    '#include "' + self._headerFilename + '"\n\n' +
                    'static void nullObjectError(char* functionName)\n' +
                    '{\n' +
                    self.indent() + 'std::string message("*** ERROR ***\\nThe given object pointer is NULL in function ");\n' +
                    self.indent() + 'message += functionName;\n' +
                    self.indent() + 'std::cout << message.c_str() << std::endl;\n' +
                    '}\n\n')

    def hadBlankLine(self, filename):
        """Adds a blank line to the file corresponding to filename."""
        with open(filename, 'a') as f:
            f.write('\n')

    def writeClass(self, class_):
        """Writes the CPPClass 'class_' to the file in a C format."""
        for constructor in class_.getConstructors():
            self.writeConstructor(constructor)

        if class_.hasDestructor():
            self.writeDestructor(class_.getDestructor())

        if class_.hasMethods():
            self.hadBlankLine(self._headerFilename)
            for method in class_.getMethods():
                self.writeMethod(class_.getName(), method)

        self.finalizeDeclaration()

    def writeConstructor(self, constructor):
        """Writes the CPPConstructor 'constructor' to the file in a C format."""
        print('Writing constructor...')

        # Handle declaration.
        decl = constructor.getName() + '_new('
        if constructor.hasParameters() > 0:
            decl = self.appendValuesToString(constructor.getParameters(), decl)
        decl += ')'
        with open(self._headerFilename, 'a') as f:
            f.write(self.indent() + constructor.getName() + '* ' + decl + ';\n')

        # Handle implementation.
        impl = ('PYBINDING_API void ' + constructor.getName() + '* ' + decl + '\n' +
                    '{\n' + self.indent() + 'return new ' + constructor.getName() + '(')
        if constructor.hasParameters():
            impl = self.appendValuesToString(constructor.getParameters(), impl)
        impl += ');\n}\n\n'
        with open(self._implementationFilename, 'a') as f:
            f.write(impl)

    def writeDestructor(self, destructor):
        """Writes the CPPDestructor 'destructor' to the file in a C format."""
        print('Writing destructor...')
        # Handle declaration.
        decl = (destructor.getName() + '_delete(' +
                destructor.getName() + '* obj)')
        with open(self._headerFilename, 'a') as f:
            f.write(self.indent() + 'void ' + decl + ';\n')

        # Handle implementation.
        impl = 'PYBINDING_API void ' + decl + '\n{\n' + self.indent()
        impl = self.appendNullObjectTestToString(impl)
        impl += '\n\n' + self.indent() + 'delete obj; obj = NULL;\n}\n\n'
        with open(self._implementationFilename, 'a') as f:
            f.write(impl)

    def writeMethod(self, className, method):
        """Writes the CPPMethod 'method' to the file in a C format."""
        print('Writing method...')
        # Handle declaration.
        decl = (str(method.getReturnValue()) + ' ' + className + '_' + method.getName() + '(' +
                className + '* obj')
        if method.hasParameters():
            decl += ', '
            decl = self.appendValuesToString(method.getParameters(), decl)
        decl += ')'
        with open(self._headerFilename, 'a') as f:
            f.write(self.indent() + decl + ';\n')

        # Handle implementation.
        impl = 'PYBINDING_API ' + decl + '\n{\n' + self.indent()
        impl = self.appendNullObjectTestToString(impl)
        impl += '\n\n' + self.indent() + 'return obj->' + method.getName() + '('
        if method.hasParameters():
            # Make a list of the parameters names and
            # add them to 'impl' separated by commas.
            parameterNames = []
            for parameter in method.getParameters():
                parameterNames.append(parameter.getName())
            impl = self.appendValuesToString(parameterNames, impl)
        impl += ');\n}\n\n'
        with open(self._implementationFilename, 'a') as f:
            f.write(impl)

    def appendValuesToString(self, values, string):
        """Append the CPPValues in values to the string in a C format.
        Remember strings are imutable, so in fact returns a new string with the appended values."""
        if len(values) == 0:
            raise Exception('The \'values\' collection must not be empty.')
        else:
            itValue = values.__iter__()
            value = itValue.next()
            while True:
                string += str(value)
                try:
                    value = itValue.next()
                except StopIteration:
                    break
                else:
                    string += ', '
        return string

    def appendNullObjectTestToString(self, string):
        """Appends the null object function test to the string.
        Remember strings are imutable, so in fact returns a new string with the appended values."""
        string += 'if(obj == NULL) nullObjectError(__FUNCTION__);'
        return string

    def indent(self, count=1):
        """Returns an indentation string corresponding to 'count', i.e., 4 spaces * count. By default, count is 1."""
        unitIndent = '    '
        return unitIndent*count
