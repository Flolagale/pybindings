#!/usr/bin/python
from cppentities import *


class CAPIWriter(object):
    """Object that can write the pure C API corresponding to a given CPPClass."""
    def __init__(self, filename, includes):
        """
        filename is the name of the files, without extension,
        to which the CAPIWriter will write text.
        includes is the list of header files that must be included in the C API header.
        """
        self._headerFilename = filename + '.h'
        self._implementationFilename = filename + '.cpp'
        self._includes = includes

    def writeClasses(self, classes):
        """Main method of the class. Writes the CPPClass collection 'classes' to the file in a C format."""
        self.initializeDeclaration()
        self.initializeImplementation()
        for class_ in classes:
            self._writeClass(class_)
        self.finalizeDeclaration()

    def _writeClass(self, class_):
        """Writes the CPPClass 'class_' to the file in a C format. This method is for internal use."""
        print("Writing class '" + class_.getName() +
            "' to files " + self._headerFilename +
            " and " + self._implementationFilename + ":")
        for constructor in class_.getConstructors():
            self.writeConstructor(constructor)

        if class_.hasDestructor():
            self.writeDestructor(class_.getDestructor())

        if class_.hasMethods():
            self.hadBlankLine(self._headerFilename)
            for method in class_.getMethods():
                self.writeMethod(class_.getName(), method)

    def initializeDeclaration(self):
        """Adds its header to the C API header file."""
        with open(self._headerFilename, 'w') as f:
            f.write('/* File automatically generated by the pybindings project.\n'
                    'This file declare a pure C API for the C++ objects.\n'
                    'The following macros represent the standard way of making\n'
                    'exporting symbols from a DLL simpler. Linux part still to do. */\n'
                    '#ifdef PYBINDING_EXPORTS\n'
                    '#define PYBINDING_API __declspec(dllexport)\n'
                    '#else\n'
                    '#define PYBINDING_API __declspec(dllimport)\n'
                    '#endif\n\n')
            # Add the includes in alphabetical order.
            for include in sorted(self._includes):
                f.write('#include "' + include + '"\n')
            f.write('\nextern "C"\n'
                    '{\n')

    def finalizeDeclaration(self):
        """Finalizes the file by closing braces etc."""
        with open(self._headerFilename, 'a') as f:
            f.write('}\n\n')

    def initializeImplementation(self):
        """Adds its header to the C API implementation file."""
        with open(self._implementationFilename, 'w') as f:
            f.write('/* File automatically generated by the pybindings project.\n' +
                    'This file implements a pure C API for the C++ objects. */\n' +
                    '#include "' + self._headerFilename + '"\n\n' +
                    'static void nullObjectError(char* functionName)\n' +
                    '{\n' +
                    self.indent() + 'std::string message("*** ERROR ***\\nThe given object pointer is NULL in function ");\n' +
                    self.indent() + 'message += functionName;\n' +
                    self.indent() + 'std::cout << message.c_str() << std::endl;\n' +
                    '}\n\n')

    def hadBlankLine(self, filename):
        """Adds a blank line to the file corresponding to filename."""
        with open(filename, 'a') as f:
            f.write('\n')

    def writeConstructor(self, constructor):
        """Writes the CPPConstructor 'constructor' to the file in a C format."""
        print(self.indent() + 'Writing constructor...')

        # Handle declaration.
        decl = constructor.getName() + '_new('
        if constructor.hasParameters() > 0:
            decl = self.appendValuesToString(constructor.getParameters(), decl)
        decl += ')'
        with open(self._headerFilename, 'a') as f:
            f.write(self.indent() + constructor.getName() + '* ' + decl + ';\n')

        # Handle implementation.
        impl = ('PYBINDING_API void ' + constructor.getName() + '* ' + decl + '\n' +
                    '{\n' + self.indent() + 'return new ' + constructor.getName() + '(')
        if constructor.hasParameters():
            impl = self.appendValuesToString(constructor.getParameters(), impl)
        impl += ');\n}\n\n'
        with open(self._implementationFilename, 'a') as f:
            f.write(impl)

    def writeDestructor(self, destructor):
        """Writes the CPPDestructor 'destructor' to the file in a C format."""
        print(self.indent() + 'Writing destructor...')
        # Handle declaration.
        decl = (destructor.getName() + '_delete(' +
                destructor.getName() + '* obj)')
        with open(self._headerFilename, 'a') as f:
            f.write(self.indent() + 'void ' + decl + ';\n')

        # Handle implementation.
        impl = 'PYBINDING_API void ' + decl + '\n{\n' + self.indent()
        impl = self.appendNullObjectTestToString(impl)
        impl += '\n\n' + self.indent() + 'delete obj; obj = NULL;\n}\n\n'
        with open(self._implementationFilename, 'a') as f:
            f.write(impl)

    def writeMethod(self, className, method):
        """Writes the CPPMethod 'method' to the file in a C format."""
        print(self.indent() + 'Writing method...')
        # Handle declaration.
        decl = (str(method.getReturnValue()) + ' ' + className + '_' + method.getName() + '(' +
                className + '* obj')
        if method.hasParameters():
            decl += ', '
            decl = self.appendValuesToString(method.getParameters(), decl)
        decl += ')'
        with open(self._headerFilename, 'a') as f:
            f.write(self.indent() + decl + ';\n')

        # Handle implementation.
        impl = 'PYBINDING_API ' + decl + '\n{\n' + self.indent()
        impl = self.appendNullObjectTestToString(impl)
        impl += '\n\n' + self.indent() + 'return obj->' + method.getName() + '('
        if method.hasParameters():
            # Make a list of the parameters names and
            # add them to 'impl' separated by commas.
            parameterNames = []
            for parameter in method.getParameters():
                parameterNames.append(parameter.getName())
            impl = self.appendValuesToString(parameterNames, impl)
        impl += ');\n}\n\n'
        with open(self._implementationFilename, 'a') as f:
            f.write(impl)

    def appendValuesToString(self, values, string):
        """Append the CPPValues in values to the string in a C format.
        Remember strings are imutable, so in fact returns a new string with the appended values."""
        if len(values) == 0:
            raise Exception('The \'values\' collection must not be empty.')
        else:
            itValue = values.__iter__()
            value = itValue.next()
            while True:
                string += str(value)
                try:
                    value = itValue.next()
                except StopIteration:
                    break
                else:
                    string += ', '
        return string

    def appendNullObjectTestToString(self, string):
        """Appends the null object function test to the string.
        Remember strings are imutable, so in fact returns a new string with the appended values."""
        string += 'if(obj == NULL) nullObjectError(__FUNCTION__);'
        return string

    def indent(self, count=1):
        """Returns an indentation string corresponding to 'count', i.e., 4 spaces * count. By default, count is 1."""
        unitIndent = '    '
        return unitIndent * count


class PyAPIWriter(object):
    """Object that can write the Python wrapper corresponding to a given CPPClass."""
    def __init__(self, filename, libraryName):
        """
        filename is the name of the file to which the Python
        wrapper will be written, for instance 'myproject.py'.
        libraryName is the shared library of dll that will contain
        the bindings and hence that will be loaded by 'myproject.py'.
        """
        self._filename = filename
        self._libraryName = libraryName
