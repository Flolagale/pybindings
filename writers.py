#!/usr/bin/python
from cppentities import *


class CAPIWriter(object):
    """Object that can write the pure C API corresponding to a given CPPClass object."""
    def __init__(self, filename):
        """filename is the name of the files, without extension, to which the CAPIWriter will write text."""
        self._headerFilename = filename + '.h'
        self._implementationFilename = filename + '.cpp'
        self.writeHeaderForHeader()
        self.writeHeaderForImplementation()

    def writeHeaderForHeader(self):
        """Adds its header to the C API header file."""
        with open(self._headerFilename, 'w') as f:
            f.write('/* File generated by the pybindings project. */\n'
                    'extern "C"\n'
                    '{\n')

    def finalizeHeader(self):
        """Finalizes the file by closing braces etc."""
        with open(self._headerFilename, 'a') as f:
            f.write('}\n\n')

    def writeHeaderForImplementation(self):
        """Adds its header to the C API implementation file."""
        with open(self._implementationFilename, 'w') as f:
            f.write('/* File generated by the pybindings project. */\n')

    def hadBlankLine(self, filename):
        """Adds a blank line to the file corresponding to filename."""
        with open(filename, 'a') as f:
            f.write('\n')

    def writeClass(self, class_):
        """Writes the CPPClass 'class_' to the file in a C format."""
        # Handle the C API header file.
        for constructor in class_.getConstructors():
            self.declareConstructor(constructor)

        if class_.hasDestructor():
            self.declareDestructor(class_.getDestructor())

        if class_.hasMethods():
            self.hadBlankLine()
            for method in class_.getMethods():
                self.declareMethod(class_.getName(), method)

        self.finalizeHeader()

        # Now handle the implementation.
        for constructor in class_.getConstructors():
            self.implementConstructor(constructor)

        if class_.hasDestructor():
            self.implementDestructor(class_.getDestructor())

        if class_.hasMethods():
            self.hadBlankLine()
            for method in class_.getMethods():
                self.implementMethod(class_.getName(), method)

    def declareConstructor(self, constructor):
        """Writes the CPPConstructor 'constructor' to the header file in a C format."""
        print('Writing constructor...')
        cline = '    ' + constructor.getName() + '_new('
        if len(constructor.getParameters()) > 0:
            cline = self.appendValuesToString(constructor.getParameters(), cline)
        cline += ');\n'

        with open(self._headerFilename, 'a') as f:
            f.write(cline)

    def declareDestructor(self, destructor):
        """Writes the CPPDestructor 'destructor' to the header file in a C format."""
        print('Writing destructor...')
        with open(self._headerFilename, 'a') as f:
            f.write('    ' + destructor.getName() + '_delete();\n')

    def declareMethod(self, className, method):
        """Writes the CPPMethod 'method' to the header file in a C format."""
        print('Writing method...')
        cline = '    ' + str(method.getReturnValue()) + ' ' + className + '_' + method.getName() + '('
        if len(method.getParameters()) > 0:
            cline = self.appendValuesToString(method.getParameters(), cline)
        cline += ');\n'

        with open(self._headerFilename, 'a') as f:
            f.write(cline)

    def implementConstructor(self, constructor):
        """Writes the CPPConstructor 'constructor' to the implementation file in a C format."""
        print('Writing constructor...')
        cline = '    ' + constructor.getName() + '_new('
        if len(constructor.getParameters()) > 0:
            cline = self.appendValuesToString(constructor.getParameters(), cline)
        cline += ');\n'

        with open(self._headerFilename, 'a') as f:
            f.write(cline)

    def implementDestructor(self, destructor):
        """Writes the CPPDestructor 'destructor' to the implementation file in a C format."""
        print('Writing destructor...')
        with open(self._headerFilename, 'a') as f:
            f.write('    ' + destructor.getName() + '_delete();\n')

    def implementMethod(self, className, method):
        """Writes the CPPMethod 'method' to the implementation file in a C format."""
        print('Writing method...')
        cline = '    ' + str(method.getReturnValue()) + ' ' + className + '_' + method.getName() + '('
        if len(method.getParameters()) > 0:
            cline = self.appendValuesToString(method.getParameters(), cline)
        cline += ');\n'

        with open(self._headerFilename, 'a') as f:
            f.write(cline)

    def appendValuesToString(self, values, string):
        """Append the CPPValues in values to the string in a C format.
        Remember strings are imutable, so in fact returns a new string with the appended values."""
        if len(values) == 0:
            raise Exception('The \'values\' collection must not be empty.')
        else:
            itValue = values.__iter__()
            value = itValue.next()
            while True:
                string += str(value)
                try:
                    value = itValue.next()
                except StopIteration:
                    break
                else:
                    string += ', '
        return string
